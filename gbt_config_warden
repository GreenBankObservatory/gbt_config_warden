#!/bin/bash

### FLAGS ###
# Bail if any statement returns non-zero
set -o errexit
# Bail if unset variable is accessed
set -o nounset
# Pipelines exit with rightmost non-zero exit code, or zero if fully successful
set -o pipefail

trap cleanup EXIT

### FUNCTIONS ###
cleanup() {
    err_code="${?}"
    if ! [ -z "${diff_file+x}" ]; then
        rm "${diff_file}"
    fi
    if ! [ -z "${body_file+x}" ]; then
        rm "${body_file}"
    fi
    # Perform any necessary cleanup actions
    exit "${err_code}"
}

die() {
    echo "$@" >&2
    exit 1
}

### MAIN ###

# Handle CLI
if [ -z "${1+x}" ]; then
    die "usage: isdirty REPO_PATH MAILTO"
else
    repo="${1}"
fi

if [ -z "${2+x}" ]; then
    die "usage: isdirty REPO_PATH MAILTO"
else
    mailto="${2}"
fi

# cd to given path
cd "${repo}"

# Create temp files
body_file=$(mktemp --suffix=.body_file)

# If the repo is dirty...
if [ -n "$(git status --untracked-files=no --porcelain)" ]; then
    diff_file=$(mktemp --suffix=.diff_file)
    echo -e "${repo} is dirty!\n" >> "${body_file}"
    git log -1 --format='Last commit: %cd by %an' >> "${body_file}"
    echo -e "\nCurrent status:\n" >> "${body_file}"
    git status --untracked-files=no --short >> "${body_file}"
    git diff > "${diff_file}"
    # Send email
    echo "" | mutt -s "GBT Config Warden Report: DIRTY" -i "${body_file}" -a "${diff_file}" -- "${mailto}"
# If the repo is clean...
else
    echo "By some miracle, ${repo} is clean!" >> "${body_file}"
    git log -1 --format='Last commit: %cd by %an' >> "${body_file}"
    echo "" | mutt -s "GBT Config Warden Report: CLEAN" -i "${body_file}" -- "${mailto}"
fi
